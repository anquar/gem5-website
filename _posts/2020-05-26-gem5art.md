---
layout: post
title:  "gem5art 公告"
author: Hoa Nguyen
date:   2020-05-26
---

<img src="/assets/img/blog/gem5art.svg" alt="gem5art-logo" width="100%" style="max-width:300px;"/>

# gem5art：gem5 实验框架
Hoa Nguyen, Ayaz Akram, Mahyar Samani, Krithiga Murugavel, Trivikram Reddy, Marjan Fariborz, Pouya Fotouhi, Jason Lowe-Power

我们很高兴宣布 gem5art 项目，这是一个旨在解决 gem5 实验可重现性问题并改进 gem5 整体测试和实验基础设施的框架。
该框架使用 Python3 编写，并利用 MongoDB 创建实验数据库。[gem5art 可通过 Python 包索引（PyPI，也称为 `pip`）下载](https://github.com/darchr/gem5art)。
要开始使用，您可以通过 `pip` 使用以下命令下载 gem5art，
```sh
pip install gem5art-artifact gem5art-run gem5art-tasks
```

## 对 gem5 实验框架的需求

gem5 模拟器为各种硬件模型和配置提供了丰富的支持，具有很高的复杂性。
然而，这种复杂性伴随着妥协。
使用 gem5 的可能性如此之多，导致缺乏运行 gem5 实验的标准方法，这反过来又导致使用 gem5 的学习曲线陡峭，并使重现 gem5 实验成为一个非平凡的过程。

设置 gem5 全系统模拟是高度非平凡过程的一个例子。
全系统实验的典型设置需要以下输入：编译的 Linux 内核、包含 Linux 发行版和已编译的所需基准测试套件的磁盘镜像、编译的 gem5 可执行文件和 gem5 系统配置。
上述实验的每个组件都对时间和环境变化敏感，其中一些需要大量时间和注意力才能正确生成输入。

例如，gem5 需要非常特定的 Linux 内核配置。
另一个例子是创建带有已安装基准测试的工作磁盘镜像。
常见的方法是使用 qemu 并手动输入命令来创建这样的磁盘镜像；这种方法通常需要几个小时和大量的人工关注，并且容易出错。
影响实验可重现性的另一个因素是编译器，它经常随时间更新。
因此，最好保留我们用于实验的组件。

与许多其他科学领域不同，我们有幸保留实验输入的*副本*，并在实验过程中保持一定程度的*确定性*。
因此，最好有一个系统的方法来生成和记录 gem5 实验；更重要的是，必须有一个运行 gem5 实验的标准方法，允许进行全面的测试和可重现性，无论是对我们自己还是其他研究人员。

## gem5art：gem5 的组件、可重现性和测试框架

gem5art 框架包含简化进行结构化 gem5 实验过程的功能：允许用户为 gem5 实验的每个组件添加重要文档（即元数据），创建备份实验输入和输出的数据库，提供检测重复实验的方法，提供示例 Linux 配置，以及提供用于自动化磁盘镜像创建的模板。

![gem5art-artifacts](/assets/img/blog/gem5art-components.png)
<br>
*图 1：设置 gem5 全系统实验的 gem5art 工作流程示例。
每个图块表示实验的一个组件，这些组件在 gem5art 启动脚本中表示为 Artifact 对象。
[可以在此处找到与设置对应的启动脚本。](https://github.com/darchr/gem5art/blob/master/docs/launch-scripts/launch_boot_tests.py)
设置包括基础仓库、gem5 仓库和 Linux 仓库作为输入；而输出组件是结果。
基础仓库包含脚本（例如启动脚本、在构建磁盘镜像时安装基准测试的脚本）和配置（例如 gem5 配置、Linux 内核配置、用于构建磁盘镜像的 Packer 配置）。
gem5 仓库和 Linux 仓库是包含相应项目源代码的 git 仓库。
结果组件表示包含 gem5 运行所有输出的压缩文件。
除了输入和输出之外，中间组件是 gem5 二进制文件、m5 二进制文件、vmlinux 二进制文件和磁盘镜像。
创建中间对象的步骤应在 gem5art 启动脚本中记录。
每个组件在注册时都会备份到数据库：对于 git 仓库，存储 git 哈希值，而对于其他组件，存储文件。
git 哈希值和文件都存储在数据库中。*

记录和备份实验的每个组件至关重要，这提高了实验的可重现性。
我们将每个输入和输出定义为实验的组件（或我们在 gem5art 中称为*组件*）。
通过为每个组件添加更多元数据（例如创建/修改日期/时间、二进制文件/源代码的版本、用于生成输入/输出的命令/步骤），我们随后拥有一个自动跟踪实验的系统，而不必手动完成。
因此，我们拥有明确定义的输入，从而拥有明确定义的实验。
添加元数据还允许检测重复实验（共享相同输入组件的实验），我们系统地避免重新运行实验，而不必记住哪些实验已经运行，从而避免浪费时间和硬件资源。
gem5art 还备份组件，以便我们可以检索用于实验的二进制文件或 git 仓库的 git 哈希值。

gem5art 还为 gem5 全系统实验设置提供支持。
如前所述，需要对默认 Linux 配置进行大量修改才能获得与 gem5 兼容的 Linux 内核。
[我们的开发仓库为多个 Linux 内核版本提供了已知的工作配置](https://github.com/darchr/gem5art/tree/master/docs/linux-configs)。
我们还提供用于创建包含多个常用基准测试套件的磁盘镜像的模板，例如 NAS Parallel Benchmarks、SPEC 2017、PARSEC。
[请遵循教程以获取更多信息](https://gem5art.readthedocs.io/en/latest/)。

## 初步结果

通过彻底记录运行 gem5 全系统实验的过程，我们简化了流程，并允许更多用户为 gem5 做出贡献。
在 6 个月的时间里，从启动测试实验的 gem5art 模板开始，我们已经开发并记录了 gem5art 框架与许多不同基准测试套件的用例，包括 NAS Parallel Benchmarks、PARSEC、SPEC 2006、SPEC 2017、GAPBS 和 Microbenchmarks。
我们还对所有基准测试套件进行了超过 4000 次实验，具有大型配置空间（例如 PARSEC 的 195 种不同配置）。

使用系统方法使我们能够进行具有大型参数空间的更明确定义的实验。
在我们较早的一篇博客文章中，我们能够[找出哪些 Linux 版本与 gem5-19 兼容](https://www.gem5.org/project/2020/03/09/boot-tests.html)，具有大型配置空间（5 个 Linux 内核版本 x 4 个 CPU 模型 x 4 个 CPU 数量 x 2 个内存系统 x 2 个启动类型）。
这样的实验在没有 gem5art 的情况下也是可能的。
然而，通过编写 gem5art 启动脚本以创建和记录组件的少量开销，我们不必担心备份组件以及记住结果文件夹的位置和结构。
只需要一个简单的查询即可从数据库获取结果。

gem5art 还允许我们进行跨实验研究。
例如，我们使用 gem5-20 进行与上述相同的实验。
由于我们记录了为 gem5-19 实验所做的工作，gem5-20 更像是一个系统过程，我们只需遵循文档，不需要记住 gem5-19 的输入是如何创建的。
只需要最少的更改（将 gem5-19 组件更改为 gem5-20 组件）。
除此之外，我们不必担心使用错误的输入（例如使用 gem5-19 二进制文件、在 gem5.googlesource.com 上检出错误的分支、使用不同的磁盘镜像），并且我们确定地知道，两个实验之间的唯一区别是 gem5 二进制文件。

gem5 实验，特别是 gem5 全系统实验，具有挑战性。
挑战不仅来自设置实验的陡峭学习曲线，还因为 Linux 内核和 gem5 正在积极开发，这使得输入参数空间随时间变得更大。
能够在如此快速变化的环境中 conducting 实验需要大量努力。
我们相信 gem5art 提供了一个框架和资源，可以缓解这一挑战，并让更多用户为 gem5 项目做出贡献。

## Workshop Presentation

<iframe width="1280" height="720" src="https://www.youtube.com/embed/x2GQa26xwzs" frameborder="0" allow="encrypted-media; picture-in-picture" allowfullscreen></iframe>
