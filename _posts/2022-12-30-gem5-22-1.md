---
layout: post
title:  "gem5-22.1 已发布！"
author: Bobby R. Bruce
date:   2022-12-30
categories: project
---

2022 年下半年，gem5 收到了来自 48 位独特贡献者的 500 次提交

v22.1 发布的前 10 名贡献者是：

- Bobby R. Bruce (143 次提交)
- Giacomo Travaglini (63 次提交)
- Gabe Black (53 次提交)
- Matthew Poremba (49 次提交)
- Jason Lowe-Power (19 次提交)
- Yu-hsin Wang (18 次提交)
- Zhantong Qiu (11 次提交)
- Earl Ou (10 次提交)
- Tiago Mück (9 次提交)
- Quentin Forcioli (9 次提交)

我们感谢所有使此 gem5 发布成为可能的 gem5 社区成员。
我们期待您对即将到来的 v23.0 发布的持续支持。

可以通过拉取 gem5 git 仓库 `stable` 分支的最新版本来获取最新版本的 gem5：

```shell
git clone https://gem5.googlesource.com/public/gem5

# or, within the gem5 repo

git switch stable
git pull
```

## 主要新功能

v22.1 发布中包含了几项新功能。
这里我们概述一些关键亮点以及如何使用它们。
有关更全面的贡献列表，请查阅[发布说明](https://gem5.googlesource.com/public/gem5/+/refs/tags/v22.1.0.0/RELEASE-NOTES.md)。

### 多 ISA 编译

在 v22.1 之前，gem5 用户只能将单个 ISA 目标编译到 gem5 二进制文件中。
例如，`scons build/X86/gem5.opt` 将创建一个仅包含 X86 ISA 的 gem5 二进制文件。
在 gem5 v22.1 中，用户可以将任何 ISA 组合编译到 gem5 二进制文件中。
`build_opts` 目录包括 `ALL`，可用于使用 `scons build/ALL/gem5.opt` 编译包含所有 ISA 目标的二进制文件。

使用多 ISA 二进制文件时，模拟中使用的 ISA 通过使用的核心指定。
例如，使用 `X86TimingSimpleCPU` 将使用 X86 ISA。
使用标准库 API 时，您可以通过指定 ISA 来设置系统处理器，像以前一样进行模拟。

Below is a simple ARM program in SE mode:

```python
from gem5.isas import ISA
from gem5.utils.requires import requires
from gem5.resources.resource import Resource
from gem5.components.memory import SingleChannelDDR3_1600
from gem5.components.processors.cpu_types import CPUTypes
from gem5.components.boards.simple_board import SimpleBoard
from gem5.components.cachehierarchies.classic.no_cache import NoCache
from gem5.components.processors.simple_processor import SimpleProcessor
from gem5.simulate.simulator import Simulator

# This ensures that the ARM ISA is compiled into the binary.
requires(isa_required=ISA.ARM)

cache_hierarchy = NoCache()
memory = SingleChannelDDR3_1600(size="32MB")

# Here we must specify the ISA we are using via the `isa` parameter.
processor = SimpleProcessor(cpu_type=CPUTypes.TIMING, isa=ISA.ARM, num_cores=1)

board = SimpleBoard(
    clk_freq="3GHz",
    processor=processor,
    memory=memory,
    cache_hierarchy=cache_hierarchy,
)

board.set_se_binary_workload(Resource("arm-hello64-static"))

simulator = Simulator(board=board)
simulator.run()
```

This can be run with `build/ALL/gem5.opt` and ARM ISA will automatically be used as it was specified via the `isa` parameter when setting `SimpleProcessor`.

### 设置基于 tick 的退出事件的 API

在运行 gem5 时，通常希望模拟在特定模拟 tick 处退出。
实现这一点的典型方法是通过移动模拟的 `MAX_TICK` 值，但这是有限的，因为它只允许将单个 tick 指定为退出事件。
直到 v22.1，用于在其他 tick 处指定退出的 API 没有很好地暴露且难以使用。
因此，以下函数已添加到 `m5` Python 模块：

- `setMaxTick(tick)`：用于指定最大模拟 tick。
- `getMaxTick()`：用于获取最大模拟 tick 值。
- `getTicksUntilMax()`：用于获取达到最大 tick 之前剩余的 tick 数。
- `scheduleTickExitFromCurrent(tick)`：用于调度在未来指定数量的 tick 处的退出事件。
- `scheduleTickExitAbsolute(tick)`：用于在指定 tick 处调度退出事件。

`setMaxTick` 函数提供了一个更清晰的接口来设置模拟要运行到的最大 tick。
当达到时，模拟器返回 `MAX_TICK` 退出事件。
`scheduleTickExit` 函数允许调度任意数量的 tick 退出事件。
当达到时，模拟器返回 `SCHEDULED_TICK` 退出事件。
`scheduleTickExitFromCurrent` 函数在未来 N 个 tick 处调度退出事件，N 由用户提供。
`scheduleTickExitAbsolute` 函数允许在特定模拟 tick 处调度（例如，在 Tick 1,000 处）。

下面是一个简单的模拟，显示在未来 100、1000、10000 和 100000 个 tick 处调度 `SCHEDULED_TICK` 退出事件。

```python
from gem5.resources.resource import Resource
from gem5.isas import ISA
from gem5.components.memory import SingleChannelDDR3_1600
from gem5.components.boards.simple_board import SimpleBoard
from gem5.components.cachehierarchies.classic.no_cache import NoCache
from gem5.components.processors.simple_processor import SimpleProcessor
from gem5.components.processors.cpu_types import CPUTypes
from gem5.simulate.simulator import Simulator
from gem5.simulate.exit_event import ExitEvent

import m5

board = SimpleBoard(
    clk_freq="3GHz",
    processor=SimpleProcessor(
        cpu_type=CPUTypes.TIMING,
        isa=ISA.X86,
        num_cores=1,
    ),
    memory=SingleChannelDDR3_1600(),
    cache_hierarchy=NoCache(),
)
board.set_se_binary_workload(Resource("x86-hello64-static"))


def scheduled_tick_generator():
    while True:
        print(f"Exiting at: {m5.curTick()}")
        yield False


simulator = Simulator(
    board=board,
    on_exit_event={ExitEvent.SCHEDULED_TICK: scheduled_tick_generator()},
)

m5.scheduleTickExitFromCurrent(100)
m5.scheduleTickExitFromCurrent(1000)
m5.scheduleTickExitFromCurrent(10000)
m5.scheduleTickExitFromCurrent(100000)

simulator.run()
```

在此脚本中，使用 Simulator 的 `on_exit_event` 参数通过打印退出时的 tick 编号来处理退出事件，然后继续模拟。
此模拟的输出将是：

```shell
Exiting at: 100
Exiting at: 1000
Exiting at: 10000
Exiting at: 100000
```

### RISCVMatchedBoard

一段时间以来，一直希望分发具有"已知良好"属性的 SimObject、stdlib 组件和系统。
也就是说，能够以与其真实世界对应物合理的保真度运行模拟的配置。
虽然仍处于早期阶段，`RISCVMatchedBoard` 是我们进入这一努力的第一步。

`RISCVMatchedBoard` 基于 SiFive 的 [HiFive Unmatched 板](https://www.sifive.com/boards/hifive-unmatched)：一个 RISC-V、64 位 Linux 开发平台，带有 SiFive Freedom U740 多核处理器。
UC Davis 的研究人员坐下来使用 HiFive Unmatched 板并仔细基准测试其属性，然后将其转换为 gem5 设计。
该设计已纳入 gem5 标准库，可以在 "src/python/gem5/prebuilt/riscvmatched/riscvmatched_board.py" 找到。

下面是一个使用 `RISCVMatchedBoard` 运行全系统模拟的示例。

```python
from gem5.prebuilt.riscvmatched.riscvmatched_board import RISCVMatchedBoard
from gem5.utils.requires import requires
from gem5.isas import ISA
from gem5.simulate.simulator import Simulator
from gem5.resources.workload import Workload

requires(isa_required=ISA.RISCV)

board = RISCVMatchedBoard(
    clk_freq="1.2GHz",
    l2_size="2MB",
    is_fs=True,
)

workload = Workload("riscv-ubuntu-20.04-boot")
board.set_workload(workload)

simulator = Simulator(board=board)
simulator.run()
```

仍在进行工作以微调此板的参数，使其更能模拟真实世界板的行为，详细信息将在未来发布以突出我们的整体成功。
我们将继续为 gem5 开发"已知良好"的系统，并将它们作为未来 gem5 发布的一部分。

### SimPoints

已添加 [SimPoints](https://doi.org/10.1145/885651.781076) 的 API。
SimPointing 是一种大幅改善模拟时间的技术。
它通过仅对模拟的代表性部分进行采样，然后相应地外推统计数据来工作。
通过这样做，可以跳过模拟程序的剩余部分。

结合 gem5 工作负载（有关工作负载的更多信息，请参见[下面的部分](#workloads)），我们可以分发带有 SimPoint 信息和 gem5 检查点的二进制文件。
然后可以通过 SimPoint API 执行这些，从而产生更快的模拟运行。

使用 SimPoints 与 gem5 的示例可以在 "configs/example/gem5_library/checkpoints/simpoints-se-checkpoint.py" 和 "configs/example/gem5_library/checkpoints/simpoints-se-restore.py" 中找到。

我们将继续扩展和微调此 API。
值得注意的是，我们将把 [LoopPoints](https://doi.org/10.1109/HPCA53966.2022.00051) 纳入 gem5 框架，这将允许 SimPoints 在多核模拟中工作（这是 SimPoints 框架的当前限制）。

### 工作负载

作为 gem5-resources 基础设施的扩展，引入了 `Workload` 的概念。
gem5-resources 基础设施在几个主要发布中提供了资源。
例如：

```python
from gem5.resources.resource import Resource

image = Resource("x86-npb")
kernel = Resource("x86-linux-kernel-5.4.49")
binary = Resource("x86-print-this")

...

board.set_se_simpoint_workload(
    binary=binary,
    arguments=["hello", 1500]
)
```

这里我们请求了三个资源。
"x86-npb" 是一个 X86 磁盘镜像，包含构建在 Ubuntu 操作系统之上的 NAS 并行基准测试套件，"x86-linux-kernel-5.4.49" 是 v5.4.49 Linux 内核，"x86-print-this" 是一个接受两个参数的二进制文件：要打印的字符串和打印次数"。
然后板被设置为运行 "x86-print-this" 二进制文件，参数为 "hello" 和 "1500"。

虽然强大，但以这种方式获取资源有一些限制。
首先，运行模拟可能需要维护多个资源。
某些资源几乎总是需要其他资源才能运行。
例如，我们的 "x86-npb" 磁盘镜像资源没有内核就无用。

除了资源的明显耦合之外，另一个问题是资源可能需要传递特定参数才有用。
例如，"x86-npb" 包含一套基准测试应用程序，但必须传递特定的命令行参数来指定要运行什么基准测试以及使用什么输入。
为了简化 gem5 的使用，我们希望用户简单地指定他们希望模拟系统运行的内容。
例如，"x86-npb-FS-input-A"。

这些问题的解决方案是工作负载。
工作负载允许捆绑资源和任何输入参数。
用户只需要指定他们希望运行的工作负载，gem5 标准库与 gem5-resources 基础设施接口，将设置模拟以正确运行。

```python
from gem5.prebuilt.demo.x86_demo_board import X86DemoBoard
from gem5.resources.workload import Workload
from gem5.simulate.simulator import Simulator

board = X86DemoBoard()

board.set_workload(Workload("x86-ubuntu-18.04-boot"))

simulator = Simulator(board=board)
simulator.run()
```

"kernel" : "x86-linux-kernel-5.4.49",
                "disk_image":"x86-ubuntu-18.04-img"

下面我们展示使用 "x86-ubuntu-18.04-boot" 工作负载。
此工作负载将使用 "x86-linux-kernel-5.4.49" 资源作为模拟内核，使用 "x86-ubuntu-18.04-img" 资源作为磁盘镜像。
引导完成后，模拟将退出。

另一个示例是 "x86-print-this-15000-with-simpoints" 工作负载。
这指定了一个 SE 工作负载，运行 "x86-print-this" 二进制资源，传递参数 "print this" 和 "1500"，以及 "x86-print-this-1500-simpoints" simpoint 资源。

在撰写本文时，以下工作负载可供使用：

- "x86-ubuntu-18.04-boot"：运行 X86 Ubuntu 18.04 引导。
- "riscv-ubuntu-20.04-boot"：运行 RISC-V Ubuntu 20.04 引导。
- "arm64-ubuntu-20.04-boot"：运行 ARM-64 Ubuntu 20.04 引导。
- "x86-print-this-15000-with-simpoints"：运行 "print-this" 二进制文件，向终端打印 15000 个 "print this" 字符串，使用 SimPoints。
- "x86-print-this-15000-with-simpoints-and-checkpoint"：运行 "print-this" 二进制文件，向终端打印 15000 个 "print this" 字符串，使用 SimPoints 和检查点。

将随着时间的推移添加更多工作负载，为 gem5 社区提供丰富多样的工作负载，他们可以将其插入到他们的模拟中。

### 开发人员的 pre-commit 检查

为了帮助 gem5 开发人员遵守 gem5 风格指南，我们已将 [pre-commit 框架](https://pre-commit.com) 添加到 gem5 仓库。
pre-commit 框架管理仓库的 git hooks。
我们使用它在执行 `git commit` 命令时通过 hook 运行对用户希望提交到代码审查的代码进行一系列检查。

特别是，我们现在对所有提交到 gem5 仓库的 Python 代码使用 [black Python 代码格式化器](https://github.com/psf/black)。

在 v22.1 中，编译 gem5 时，如果尚未安装，将询问用户是否希望安装 pre-commit hook。
在用户同意的情况下，将安装 hook。
如果用户希望手动安装 hook，可以通过在 gem5 仓库中运行以下命令来完成：

```shell
pip install -r requirements.txt
./util/pre-commit-install.sh
```

安装后，执行 `git commit` 时将处理任何暂存的代码。
用户还可以使用以下命令对他们希望的任何文件或目录运行 pre-commit：

```shell
pre-commit run --files path/to/file/or/directory
```

**我们强烈建议用户安装 pre-commit hooks**。
我们的代码审查预提交 CI 测试已使用 pre-commit 测试进行更新。
如果它们失败，用户将无法将其补丁合并到代码库中，直到重构代码以使 pre-commit 测试通过。

### GPU 全系统模式

在 v21.2 中，我们引入了系统调用仿真 (SE) 模式的 GPU 支持，在 v22.0 中，我们为全系统 (FS) 支持奠定了早期框架。
在 v22.1 中，我们很高兴地宣布在 FS 模式下对 GPU 模拟的显著改进支持。

直到 v22.1，SE 模式由于其相对稳定性而受到青睐。
但是，GPU SE 模拟需要用户在主机系统上具有非常特定的环境，主要是由于 GPU 模拟器需要非常特定的 ROCm 软件堆栈来动态链接到工作负载。
创建了 Docker 容器来提供此环境，这自然要求所有模拟都在容器内进行。

GPU 模拟的 FS 模式的完全整合消除了所有主机要求，所有 SE 模式模拟都可以作为 FS 模式模拟运行。

GPU FS 模式还通过功能性地模拟内存复制提高了模拟速度，并为 gem5 开发人员提供了更容易的更新路径。

目前，我们强烈建议用户在 X86 主机上使用 KVM 模式运行 GPU FS 模式，以跳过引导和其他不相关的模拟任务。
GPU 模拟非常消耗资源，因此应注意不要模拟不必要的代码。

## 社区事务

2022 年夏天，我们在 UC Davis 举办了 gem5 Bootcamp。
这是同类中的第一个，Bootcamp 旨在为早期计算机体系结构研究人员提供机会，在为期 5 天的强化课程中学习 gem5。
在超过 80 名申请者中，由于场地限制，我们选择了 50 名，并于 7 月举办了 Bootcamp，在 UC Davis 住宿中接待了所有与会者。

该课程经过精心设计，将研究人员（其中大多数是一年级博士生）从对 gem5 的非常基本的理解带到复杂的任务，例如添加 ISA 指令、开发模型、了解 gem5 CPU 模型中的各种差异、加速模拟和 gem5 GPU 模型。
利用专业知识和 UC Davis，我们还能够在特殊的 1 对 1 会议中为与会者提供关于如何将 gem5 用于其特定研究议程的定制建议。
在活动后进行的调查中，发现 95% 的与会者"强烈同意" Bootcamp 对他们开始使用 gem5 很有价值，100% 的与会者"更可能"或"更可能"在他们的研究中使用 gem5。

我们已努力通过[我们的 YouTube 频道](https://youtube.com/playlist?list=PL_hVbFs_loVSaSDPr1RJXP5RRFWjBMqq3)归档活动，并将教学材料封装在 [Bootcamp 网站](https://gem5bootcamp.github.io/gem5-bootcamp-env/)中。
我们鼓励用户利用这些资源来学习 gem5。

### Future events

In the February 2023 we'll be holding a [gem5 Tutorial at HPCA](https://www.gem5.org/events/hpca-2023).
This tutorial will give attendees a 3-hour crash course in using gem5.
This will include emphasis on new gem5 features, such as that incorporated into the v22.1 release.
Based on feedback from previous tutorials, we will also include a short session on using the GPU FS model in gem5.

In July (10th to the 14th), UC Davis will be hosting the 2nd gem5 Bootcamp.
With similar goals to the Bootcamp held in 2023, this event will give an intensive 5 day course for early-career computer architecture researchers, particularly those in the first two years of a PhD programme.
Please join the [gem5 announce mailing list](https://www.gem5.org/ask-a-question/) or keep an eye on or [gem5 events page](https://www.gem5.org/events) for upcoming information on registering interest for this event.
