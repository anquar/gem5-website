---
layout: post
title:  "使用 Guix 解决 gem5 打包问题的理由"
author: Christopher Batten<sup>1</sup>, Pjotr Prins<sup>2</sup>, Efraim Flashner<sup>2</sup>, Arun Isaac<sup>2</sup>,Ekaiz Zarraga<sup>2</sup>, Erik Garrison<sup>2</sup>, Tuan Ta<sup>1</sup>
date:   2022-05-23
categories: project
---

<sup>1</sup> School of Electrical and Computer Engineering, Cornell University, Ithaca, NY <br>
<sup>2</sup> The University of Tennessee Health Science Center, Memphis, TN <br>
<sup>3</sup> ElenQ Technology

本文首先将描述 gem5 打包问题，然后说明使用 Guix（一个成熟的功能性跨平台包管理器）来构建、分发、安装和管理 gem5 生态系统的理由。

gem5 打包问题
--------------------------------------------------------------------------

gem5 模拟器已成为周期级模拟的事实标准，gem5 现在支持评估各种工作负载。
不幸的是，gem5 模拟器和 gem5 工作负载仍然缺乏引人注目的软件打包解决方案来简化构建、分发、安装和管理 gem5 生态系统。在本节中，我们描述 gem5 模拟器和工作负载打包问题，然后概述理想的软件打包解决方案。

**gem5 模拟器打包问题**——gem5 模拟器是一个复杂的软件，具有许多构建时和运行时依赖项，包括现代 C++ 编译器、SCons、Boost 和 Python。为了缓解依赖项问题，gem5 安装说明强烈建议使用特定版本的 Ubuntu。gem5 模拟器有许多编译时选项来实验不同的 ISA、一致性协议和/或加速器，这反过来使得提供单个预编译二进制文件变得困难。即便如此，gem5 社区确实向新研究人员指向少数预编译的 Docker 镜像。鉴于这些挑战，gem5 社区选择不支持任何类型的 gem5 模拟器打包。几乎所有研究人员都单独管理依赖项并从源代码重新编译 gem5 模拟器。

**gem5 工作负载打包问题**——使用系统调用仿真在 gem5 模拟器上构建要运行的工作负载可能与构建 gem5 模拟器本身一样具有挑战性。这些工作负载必须进行交叉编译，这意味着研究人员必须为每个目标架构构建完整的交叉编译工具链。研究人员可能还需要构建模拟器（例如，QEMU）以在进入周期级模拟之前测试这些工作负载。研究人员必须确保工作负载仅使用静态库并且不调用任何不支持的系统调用。鉴于这些挑战，gem5 社区多年来直接将预编译二进制文件作为 gem5 源代码分发的一部分包含在内。最近，社区已迁移到作为 gem5 资源项目一部分的预编译二进制文件。

理想的软件打包解决方案应该是：*可重现的*——轻松复制精确指定的开发环境；*透明的*——了解整个开发环境，包括确切的构建配置和每个依赖项的版本；*可组合的*——轻松将 gem5 模拟器和工作负载集成到标准开发环境中，无需笨重、重量级的容器；*快速的*——利用预编译包；*发行版无关的*——使研究人员能够使用他们选择的 Linux 发行版；*统一的*——相同的打包解决方案可用于 gem5 模拟器和工作负载；*可移植的*——轻松构建 gem5 工作负载以进行本机执行和/或针对多个 ISA 进行周期级模拟，而无需手动管理多个交叉编译工具链；以及*灵活的*——轻松在开发环境之间切换、修改现有包、添加新包、生成可重现的工作流和/或生成容器。

## 使用 Guix 进行 gem5

Guix 是一个成熟的功能性跨平台包管理器，拥有数百名提交者和超过 20K 个包。在本节中，我们简要描述我们使用 Guix 打包 gem5 模拟器和 gem5 工作负载的持续努力。

**使用 Guix 打包 gem5 模拟器**——我们为 gem5 模拟器开发了一个概念验证 Guix 包，它处理所有构建时和运行时依赖项以及安装[^1]。该包为六个 ISA 构建 gem5，通过消除 `|__DATE__|` 和 `|__TIME__|` 的非确定性使用来确保构建是可重现的，修补构建环境以与 SCons 一起工作，并执行 gem5 模拟器二进制文件和示例配置的结构化安装。该包是：*可重现的*，通过使用隔离和确定性的环境来实验 gem5 模拟器；*透明的*，因为完整的递归依赖图被精确指定；*可组合的*，因为 gem5 模拟器像任何其他工具一样安装，无需容器；以及*发行版无关的*，因为该包可以安装在 Ubuntu、RHEL、SUSE 甚至 Guix System 上，Guix System 是完全基于 Guix 的整个发行版。派生包可以轻松地为不同的编译时配置提供包。当合并到主 Guix 包仓库的上游时，此包将成为 Guix 构建农场的一部分，实现二进制包替换以进行*快速*安装。

**使用 Guix 打包 gem5 工作负载**——Guix 已经包括 QEMU 的包和商业 ISA 的交叉编译工具链。我们正在为 Guix 的 RISC-V 端口做出贡献，包括打包 RISC-V 交叉编译工具链。我们确定了一个简单的 Smith-Waterman 序列比对 Guix 包作为有趣的 gem5 工作负载，并开发了一个派生 Guix 包，它修补标准构建过程以生成静态链接的二进制文件[^2]。除了*可重现的*、*透明的*、*可组合的*和*发行版无关的*之外，使用 Guix 也是*可移植的*，因为我们可以轻松地为 ARM 或 RISC-V 交叉编译包，并且*灵活的*，因为它只需要八行 Guile 代码来创建支持静态编译的新派生包。

## Case Study

The attached appendix describes step-by-step commands for a case study
that: installs QEMU, gem5, and cross-compilers for x86, ARM, and RISC-V
in an isolated environment; cross-compiles and runs Smith-Waterman for
all three ISAs; and runs this benchmark on the in-order and out-of-order
timing models. To reproduce this case study, a researcher first must
download and install Guix[^3].

### Add new channel

By default, Guix includes its own main package repository, but users can
also create their own ``channels'' that include third-party packages. We
need to add such a channel to get access to the gem5 simulator package
and the derived Smith-Waterman package.

     % cd $HOME/.config/guix
     % cat > channels.scm \
    <<'END'
    (use-modules (guix ci))
    (list
     (channel
      (name 'gn-bioinformatics)
      (url (string-append "https://git.genenetwork.org/"
             "guix-bioinformatics/guix-bioinformatics.git"))
      (branch "master"))
     (channel-with-substitutes-available
      %default-guix-channel "https://ci.guix.gnu.org"))
    END

### Update Guix and install Smith-Waterman

We use `guix pull` to download all of the package descriptions from the
main package repository along with any third-party packages. We then
install the default Smith-Waterman package and run it natively. Here we
使用默认的 "profile"，但我们也可以将此包安装在专用的 Guix "profile" 中，类似于 Python 的虚拟环境。

    % mkdir -p $HOME/tmp/misc/test-guix
    % cd $HOME/tmp/misc/test-guix
    % guix pull
    % guix install smithwaterman
    % smithwaterman -p TGATTGTACCAAA TGATCATGTACCA

### 安装 QEMU 和 gem5

我们现在在同一 profile 中为所有架构安装 QEMU 和 gem5 包。

    % guix install qemu
    % guix install gem5

### 为 x86_64 ISA 构建和运行 Smith-Waterman

我们使用 `guix build --target=x86_64-linux-gnu` 为 x86_64 交叉编译大多数 Guix 包。这里我们交叉编译 Smith-Waterman 的派生包，它生成一个静态链接的可执行文件，然后我们在 QEMU 和 gem5 上运行它。

    % cd $HOME/tmp/misc/test-guix
    % DIR=$(guix build \
             --target=x86_64-linux-gnu smithwaterman-static)
    % ln -sf $DIR/bin/smithwaterman sw-x86_64
    % qemu-x86_64 ./sw-x86_64 -p TGATTGTACCAAA TGATCATGTACCA
    % gem5-x86.opt \
        $GUIX_PROFILE/share/gem5/configs/example/se.py \
        --cmd=./sw-x86_64 \
        --options="-p TGATTGTACCAAA TGATCATGTACCA"

### 为 ARM ISA 构建和运行 Smith-Waterman

我们使用 `guix build --target=aarch64-linux-gnu` 为 ARM 交叉编译大多数 Guix 包。这里我们交叉编译 Smith-Waterman 的派生包，它生成一个静态链接的可执行文件，然后我们在 QEMU 和 gem5 上运行它。

    % cd $HOME/tmp/misc/test-guix
    % DIR=$(guix build \
             --target=aarch64-linux-gnu smithwaterman-static)
    % ln -sf $DIR/bin/smithwaterman sw-aarch64
    % qemu-aarch64 ./sw-aarch64 -p TGATTGTACCAAA TGATCATGTACCA
    % gem5-arm.opt \
        $GUIX_PROFILE/share/gem5/configs/example/se.py \
        --cmd=./sw-aarch64 \
        --options="-p TGATTGTACCAAA TGATCATGTACCA"

### 为 RISC-V ISA 构建和运行 Smith-Waterman

我们使用 `guix build --target=riscv64-linux-gnu` 为 RISC-V 交叉编译大多数 Guix 包。这里我们交叉编译 Smith-Waterman 的派生包，它生成一个静态链接的可执行文件，然后我们在 QEMU 和 gem5 上运行它。

    % cd $HOME/tmp/misc/test-guix
    % DIR=$(guix build \
             --target=riscv64-linux-gnu smithwaterman-static)
    % ln -sf $DIR/bin/smithwaterman sw-riscv64
    % qemu-riscv64 ./sw-riscv64 -p TGATTGTACCAAA TGATCATGTACCA
    % gem5-riscv.opt \
        $GUIX_PROFILE/share/gem5/configs/example/se.py \
        --cmd=./sw-riscv64 \
        --options="-p TGATTGTACCAAA TGATCATGTACCA"

### 在 RISC-V ISA 上运行实验

一旦我们使用 Guix 安装了 gem5 模拟器和 gem5 工作负载包，我们就可以轻松执行计算机体系结构研究实验。这里我们比较在顺序与乱序 RISC-V 处理器模型上运行 Smith-Waterman 的性能。

    % cd $HOME/tmp/misc/test-guix

    % gem5-riscv.opt \
        --outdir=m5out-minor-sw \
        $GUIX_PROFILE/share/gem5/configs/example/se.py \
        --cmd=./sw-riscv64 \
        --options="-p TGATTGTACCAAA TGATCATGTACCA" \
        --cpu-type=MinorCPU --ruby

    % gem5-riscv.opt \
        --outdir=m5out-o3-sw \
        $GUIX_PROFILE/share/gem5/configs/example/se.py \
        --cmd=./sw-riscv64 \
        --options="-p TGATTGTACCAAA TGATCATGTACCA" \
        --cpu-type=O3CPU --ruby

    % grep system.cpu.numCycles m5out-minor-sw/stats.txt
    % grep system.cpu.numCycles m5out-o3-sw/stats.txt

致谢
--------------------------------------------------------------------------

这项工作得到了 NSF PPoSS Award #2118709 以及 GNUMes-RISCV 和 Guix-Riscv64 的 NLNet 奖项的支持。

[^1]: <https://git.genenetwork.org/guix-bioinformatics/guix-bioinformatics/src/branch/master/gn/packages/virtualization.scm>
[^2]: <https://git.genenetwork.org/guix-bioinformatics/guix-bioinformatics/src/branch/master/gn/packages/static.scm>
[^3]: <https://guix.gnu.org/en/download>
