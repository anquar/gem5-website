---
layout: documentation
title: "MI example"
doc: gem5 documentation
parent: ruby
permalink: /documentation/general_docs/ruby/MI_example/
author: Jason Lowe-Power
---

# MI Example

### 协议概述

  - 这是一个简单的缓存一致性协议，用于说明使用 SLICC 进行协议规范。
  - 该协议假设 1 级缓存层次结构。缓存对每个节点都是私有的。缓存由目录控制器保持一致性。由于层次结构只有 1 级，因此没有包含/排他要求。
  - 该协议不区分加载和存储。
  - 该协议无法实现 LL/SC 指令的语义，因为在 LL/SC 序列中命中块的外部 GETS 请求会窃取独占权限，从而导致 SC 指令失败。

### 相关文件

  - **src/mem/protocols**
      - **MI_example-cache.sm**: 缓存控制器规范
      - **MI_example-dir.sm**: 目录控制器规范
      - **MI_example-dma.sm**: DMA 控制器规范
      - **MI_example-msg.sm**: 消息类型规范
      - **MI_example.slicc**: 容器文件

### 稳定状态和不变式

| 状态 | 不变式                                                                                                   |
| ------ | ------------------------------------------------------------------------------------------------------------ |
| **M**  | 缓存块已被该节点访问（读取/写入）。没有其他节点持有该缓存块的副本 |
| **I**  | 该节点处的缓存块无效                                                                      |

**控制器 FSM 图中使用的符号在[此处](#Coherence_controller_FSM_Diagrams "wikilink")描述。**

### 缓存控制器

  - 请求、响应、触发器：
      - 来自核心的加载、指令获取、存储
      - 来自自身的替换
      - 来自目录控制器的数据
      - 来自目录控制器的转发请求（干预）
      - 来自目录控制器的写回确认
      - 来自目录控制器的无效化（在 DMA 活动时）

![MI_example_cache_FSM.jpg](/assets/img/MI_example_cache_FSM.jpg
"MI_example_cache_FSM.jpg")

  - 主要操作：
      - 在来自核心的**加载/指令获取/存储**请求时：
          - 它检查相应的块是否存在于 M 状态。如果是，则返回命中
          - 否则，如果在 I 状态，它从目录控制器发起 GETX 请求

     - 在来自自身的**替换**触发器时：
          - 它驱逐块，向目录控制器发出写回请求
          - 它等待来自目录控制器的确认（以防止竞争）

     - 在来自目录控制器的**转发请求**时：
          - 这意味着当某个其他节点生成请求时，该块在此节点处于 M 状态
          - 它直接将块发送到请求节点（缓存到缓存传输）
          - 它从此节点驱逐块

     - **无效化**类似于替换

### 目录控制器

  - 请求、响应、触发器：
      - 来自核心的 GETX，转发到核心的 GETX
      - 来自内存的数据，发送到核心的数据
      - 来自核心的写回请求，发送到核心的写回确认
      - 来自 DMA 控制器的 DMA 读取、写入请求

![MI_example_dir_FSM.jpg](/assets/img/MI_example_dir_FSM.jpg
"MI_example_dir_FSM.jpg")

  - 主要操作：
      - 目录维护跟踪哪个核心在 M 状态下拥有块。它将该核心指定为块的所有者。
      - 在来自核心的 **GETX** 请求时：
          - 如果块不存在，则发起内存获取请求
          - 如果块已存在，则意味着请求是从某个其他核心生成的
              - 在这种情况下，将转发请求发送到原始所有者
              - 块的所有权转移给请求者
      - 在来自核心的**写回**请求时：
          - 如果核心是所有者，则将数据写入内存并向核心发送确认
          - 如果核心不是所有者，则发送 NACK
              - 这可能在竞争条件下发生
              - 核心在某个其他核心的转发请求正在途中时驱逐了块，目录已经为核心更改了所有权
              - 驱逐核心持有数据直到转发请求到达
      - 在 **DMA** 访问（读取/写入）时
          - 将无效化发送到所有者节点（如果有）。否则从内存获取数据。
          - 这确保最新的数据可用。

### 其他功能

  - MI 协议不支持 LL/SC 语义。来自远程核心的加载将使缓存块无效。
  - 该协议没有超时机制。
